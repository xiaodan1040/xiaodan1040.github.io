{"categories":[{"title":"python","uri":"https://xiaodan1040.github.io/categories/python/"},{"title":"内置函数","uri":"https://xiaodan1040.github.io/categories/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"title":"面试题","uri":"https://xiaodan1040.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"posts":[{"content":"前端方面： 1）将静态文件（js、css、静态图片等）存放在CDN中或设置专门服务器\n2）使用精灵图（就是所有的图片放在一张大图上，使用定位，定位到需要的图片上）\n3）前端缓存（响应头设置缓存时间）cache-control\nnginx 方面： 1）nginx 做集群（DNS解析，负载均衡硬件）\n2）动静分离（静态资源直接通过nginx转发，uwsgi只负责处理动态请求）\n3）负载均衡（nginx配置）\n4）集群化部署\n5）使用微服务架构（拆服务，将项目做成分布式）\n部署方式： 1）uwsgi（c写的wsgi服务器）部署\n2）gunicorn（python写的wsgi服务器）部署\n后端代码： 1）缓存(redis)\n场景说明：接收一个请求，要查5个表，耗时3s \u0026ndash;\u0026gt; json 格式 \u0026ndash;\u0026gt; 放到缓存中 \u0026ndash;\u0026gt; 下次再发送请求，直接去缓存查 \u0026ndash;\u0026gt; 耗时大大减少，可能0.001秒返回了\n弊端：可能会出现缓存击穿、缓存穿透、缓存雪崩以及双写一致性问题等\n2）页面静态化(只适用于web项目)，将访问频繁的页面（比如首页）提前生成\n场景说明：发送请求 /index \u0026ndash;\u0026gt; 查询数据库（用了缓存）\u0026ndash;\u0026gt; dtl渲染页面 \u0026ndash;\u0026gt; 提前生成出index.html \u0026ndash;\u0026gt; django模板渲染\ndjango实现页面静态化的过程\ndef current_time(req): # ================================原始的视图函数 # import datetime # now=datetime.datetime.now() # html=\u0026quot;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;现在时刻：\u0026lt;h1\u0026gt;%s.\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026quot; %now # ================================django模板修改的视图函数 # from django.template import Template,Context # now=datetime.datetime.now() # t=Template('\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;现在时刻是:\u0026lt;h1\u0026gt;{{current_date}}\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;') # #t=get_template('current_datetime.html') # c=Context({'current_date':str(now)}) # html=t.render(c) # # return HttpResponse(html) #另一种写法(推荐) import datetime now=datetime.datetime.now() return render(req, 'current_datetime.html', {'current_date':str(now)[:19]})  弊端：可能会出现数据不一致的情况\n3）异步操作（celery），将耗时长的请求（比如需要3s），设计成异步\n场景说明：接收到请求 \u0026ndash;\u0026gt; 直接返回消息(任务已提交，请求正在处理)\n案例：\n① 小米秒杀：您正在排队（前端设置了定时，每隔5s，发送一个请求，查是否秒杀成功）\n② 保存视频，发送邮件\n③ 后台管理中统计最近某几个月的订单量 \u0026ndash;\u0026gt; 折线图、饼状图展示\n④ 消息队列：rabbitmq、kafka，用于异步，解耦\n4）请求达到数据库（只要达到数据库，性能就下来了）\n① 优化sql，尽量不建立外键，适当建索引\n② 读写分离，数据库集群，分库分表\n5）优化代码，多线程处理，尽量不在for循环里查数据库\n6）换框架(异步框架，例如sanic，fastapi)，换语言(例如go)\n最本质就一句话，代码优化不了了，垒机器\n弊端的解决方案 问题1：使用缓存，出现缓存击穿、缓存穿透、缓存雪崩以及双写一致性问题如何解决 摘自：\nhttps://baijiahao.baidu.com/s?id=1619572269435584821\u0026amp;wfr=spider\u0026amp;for=pc\nhttps://zhuanlan.zhihu.com/p/91539644\n缓存击穿\n缓存击穿，是指某个热点数据(key)失效时，大量针对这个数据的请求直接访问数据库\n解决方案\n1 使用随机退避方式，失效时随机sleep一个很短的时间，再次查询，如果失败再执行更新。对电商项目，则可考虑将这些热点数据设置为“爆款产品”，让其永不过期\n2 使用互斥锁更新，保证同一个进程中针对同一数据不会并发访问到数据库，减少数据库压力\n缓存穿透\n缓存穿透，是指查询一个数据库一定不存在的数据。通常产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户ID频繁请求接口，使缓存不命中，然后访问数据库依然不命中，导致大量请求穿透缓存访问数据库\n解决方案\n1 采用缓存空值的方式，如果从数据库查询的对象为空，也放入缓存，为其设置一个非常短的缓存过期时间，比如60s。不过这个方法可能导致缓存中存储大量无用数据\n2 使用布隆过滤器(BloomFilter)，布隆过滤器的特点是存在性检测，如果布隆过滤器中不存在，数据一定不存在；如果布隆过滤器中存在，实际数据也可能不存在\n缓存雪崩\n缓存雪崩，是指在某一个时间段，缓存数据集中过期失效，在此期间所有的请求都会穿透访问数据库\n解决方案\n1 针对多个热点数据(key)同时失效的问题，可将这些key 进行分类，根据分类设置不同的时间周期，再对每个分类中的时间周期上增加一个小的随机数，避免大量热点key同一时刻失效\n2 缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。 比如对某个key只允许一个线程查询数据和写缓存，其他线程等待(参考zookeeper)\n3 使用主从模式和集群模式来尽量保证缓存服务的高可用\n4 使用快速失败的熔断策略，减少数据库瞬间压力(参考Java)\n双写一致性\n只要使用缓存，就可能涉及到缓存与数据库双存储双写，只要双写，就一定会存在数据不一致问题\n解决方案\n1 服务对耗时不是特别敏感可以增加重试，耗时敏感可通过异步补偿任务来处理失败的更新。短期数据不一致不影响业务，下次更新成功，只要最终一致性即可\n2 短期数据不一致不影响业务，可采用，只要最终一致性即可\n3 延时双写或延时双删策略\n4 强一致性的，可使用悲观锁或读写请求串行化，串到一个内存队列中\n问题2：页面静态化的过程中，出现数据不一致的问题如何解决 1 异步检测，当有数据增加时，再重新生成一次这个页面\n2 使用celery或django的信号(异步操作)，当对象保存时，重新生成静态页面\n","id":0,"section":"posts","summary":"前端方面： 1）将静态文件（js、css、静态图片等）存放在CDN中或设置专门服务器 2）使用精灵图（就是所有的图片放在一张大图上，使用定位，定","tags":["并发量"],"title":"面试题：如何提高项目并发量","uri":"https://xiaodan1040.github.io/increase_concurrency/","year":"2020"},{"content":"python基础面试题 1、手写一个完整的装饰器模板 # 用于修复被装饰对象的名称空间 from functools import wrape def wapper(func): @wraps(func) def inner(*args, **kwargs): # func执行前的操作 res = func(*args, **kwargs) # func执行后的操作 return res return inner  2、你所知道的能够实现单例模式的方式有哪些，尝试写几个 单例模式：让所有类在实例化时，指向同一内存地址\n实现单例模式的5种方式：\n 通过关键字classmethod 实现 通过装饰器实现 通过__new__ 魔法方法实现 通过导入模块实现 通过元类实现  # 通过关键字classmethod 实现 class Singleton: def __init__(self, *args, **kwargs): pass @classmethod def instance(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = cls(*args, **kwargs) return cls._instance  # 通过装饰器实现 def singleton(cls): _instance = {} def inner(*args, **kwargs): if cls not in _instance: _instance[cls] = cls(*args, **kwargs) return _instance[cls] return inner  # 通过__new__ 魔法方法实现 class Singleton: def __new__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super().__new__(cls) return cls._instance  # 通过导入模块实现 # a.py 被导入的模块 class Singleton: def __init__(self): pass singleton_obj = Singleton() # b.py 导入a.py 模块 from a import singleton_obj print singleton_obj  # 通过元类实现 class SingletonMeta(type): def __call__(cls, *args, **kwargs): if not hasattr(cls, '_instance'): cls._instance = super().__call__(*args, **kwargs) return cls._instance class Singleton(metaclass=SingletonMeta): def __init__(self): pass  3、举例说明map、zip、filter、sorted、reduce 内置函数的作用 *map(func, iterable)\n映射：将函数func用于可迭代对象中的元素，所得到的每个返回值映射到一个map 对象中，可将这个map 对象转换其他容器类型展示结果。只能转换一次，原理：map对象本质是可迭代对象。tuple(map_obj) 或for num in map_obj这样的语句，就是调用了迭代器，执行了 __next__()，再次使用map_obj，里面的内容已被取完\n'''求列表[1,2,3,4,5,6,7,8,9],返回一个n*n 的列表 ''' li = [1, 2, 3, 4, 5, 6, 7, 8, 9] map_obj = map(lambda x: x ** 2, li) print(f'map 对象：{map_obj}') \u0026gt;\u0026gt;\u0026gt; map 对象：\u0026lt;map object at 0x000001F6AEA62588\u0026gt; print(f'转换成元组展示：{tuple(map_obj)}') \u0026gt;\u0026gt;\u0026gt; 转换成元组展示：(1, 4, 9, 16, 25, 36, 49, 64, 81) print(f'转换成列表展示：{list(map_obj)}') \u0026gt;\u0026gt;\u0026gt; 转换成列表展示：[]  *zip(iterable)\n并行迭代：将多个可迭代对象中元素，一一对应打包成一个个元组，将这些元组存放在zip对象中。参数序列不等长，会自动甄别，忽略多余的元素\nli1 = ['name', 'age', 'hobby'] li2 = ['dawn', 28] zip_obj = zip(li1, li2) print(zip_obj) \u0026gt;\u0026gt;\u0026gt; \u0026lt;zip object at 0x0000023ECA4C87C8\u0026gt; print(dict(zip_obj)) \u0026gt;\u0026gt;\u0026gt; {'name': 'dawn', 'age': 28} print(tuple(zip_obj)) \u0026gt;\u0026gt;\u0026gt; ()  filter(func, iterable)\n过滤：通过函数fun判断可迭代对象中的元素是否符合条件，筛选符合条件的元素存放到filter 对象中\n'''求列表['1A','2A','3C','4C','5A']中，返回不包含A的列表 ''' key_list = ['1A', '2A', '3C', '4C', '5A'] filter_obj = filter(lambda key: key.endswith('C'), key_list) print(f'filter 对象：{filter_obj}') \u0026gt;\u0026gt;\u0026gt; filter 对象：\u0026lt;filter object at 0x000002D05C3A95C8\u0026gt; print(f'转换成元组展示：{tuple(filter_obj)}') \u0026gt;\u0026gt;\u0026gt; 转换成元组展示：('3C', '4C') print(f'转换成列表展示：{list(filter_obj)}') \u0026gt;\u0026gt;\u0026gt; 转换成列表展示：[]，原理同map()  sorted(iterable, func, reverser=False)\n排序：通过函数func制定排序规则，对可迭代对象中的元素进行排序，默认为升序，返回一个新的列表\ntuple_obj = ('ada', 'afdf', 'asdasdsasda', 'asdasdf', 'sss') list_obj = sorted(tuple_obj, key=lambda s: s.count('a'), reverse=True) print(list_obj) \u0026gt;\u0026gt;\u0026gt; ['asdasdsasda', 'ada', 'asdasdf', 'afdf', 'sss'] print(tuple(list_obj)) \u0026gt;\u0026gt;\u0026gt; ('asdasdsasda', 'ada', 'asdasdf', 'afdf', 'sss')  reduce(func, sequence, initial=None)\n合并：通过函数对参数序列中元素进行累积计算，即：reduce(func,[1,2,3]) \u0026lt;=\u0026gt; func(func(1,2),3)。注意：使用reduce，需要导入functools 模块，且求和累积，初始值为0，乘积累积，初始值为1\nfrom functools import reduce # 求1-100之内的和 res_sum = reduce(lambda x, y: x + y, range(1, 101)) print(res_sum) # 求1-9的积 res_pro = reduce(lambda x, y: x * y, range(1, 10)) print(res_pro)  4、列举常用的内置函数 数学运算方面\nabs(a) : 求取绝对值。abs(-1) max(list) : 求取list最大值。max([1,2,3]) min(list) : 求取list最小值。min([1,2,3]) sum(list) : 求取list元素的和。 sum([1,2,3]) \u0026gt;\u0026gt;\u0026gt; 6 len(list) : list长度,len([1,2,3]) divmod(a,b): 获取商和余数。 divmod(5,2) \u0026gt;\u0026gt;\u0026gt; (2,1) pow(a,b) : 获取乘方数。pow(2,3) \u0026gt;\u0026gt;\u0026gt; 8 round(a,b) : 获取指定位数的小数。a代表浮点数，b代表要保留的位数。round(3.1415926,2) \u0026gt;\u0026gt;\u0026gt; 3.14 range(a[,b]) : 生成一个a到b的数组,左闭右开。 range(1,10) \u0026gt;\u0026gt;\u0026gt; [1,2,3,4,5,6,7,8,9]  数据类型转换\nint(str) : 转换为int型。int('1') \u0026gt;\u0026gt;\u0026gt; 1 float(int/str) : 将int型或字符型转换为浮点型。float('1') \u0026gt;\u0026gt;\u0026gt; 1.0 str(int) : 转换为字符型。str(1) \u0026gt;\u0026gt;\u0026gt; '1' bool(int) : 转换为布尔类型。 str(0) \u0026gt;\u0026gt;\u0026gt; False str(None) \u0026gt;\u0026gt;\u0026gt; False list(iterable) : 转换为list。 list((1,2,3)) \u0026gt;\u0026gt;\u0026gt; [1,2,3] tuple(iterable) : 转换为tuple。 tuple([1,2,3]) \u0026gt;\u0026gt;\u0026gt;(1,2,3) dict(iterable) : 转换为dict。 dict([('a', 1), ('b', 2), ('c', 3)]) \u0026gt;\u0026gt;\u0026gt; {'a':1, 'b':2, 'c':3} set(iterable) : 转换为set。 set([1,4,2,4,3,5]) \u0026gt;\u0026gt;\u0026gt; {1,2,3,4,5} set({1:'a',2:'b',3:'c'}) \u0026gt;\u0026gt;\u0026gt; {1,2,3} bytes(str,code) : 接收一个字符串，与所要编码的格式，返回一个字节流类型。bytes('abc', 'utf-8') \u0026gt;\u0026gt;\u0026gt; b'abc' bytes(u'爬虫', 'utf-8') \u0026gt;\u0026gt;\u0026gt; b'\\xe7\\x88\\xac\\xe8\\x99\\xab' iter(iterable)： 返回一个可迭代的对象。 iter([1,2,3]) \u0026gt;\u0026gt;\u0026gt; \u0026lt;list_iterator object at 0x0000000003813B00\u0026gt; enumerate(iterable) : 返回一个枚举对象。 hex(int) : 转换为16进制。hex(1024) \u0026gt;\u0026gt;\u0026gt; '0x400' oct(int) : 转换为8进制。 oct(1024) \u0026gt;\u0026gt;\u0026gt; '0o2000' bin(int) : 转换为2进制。 bin(1024) \u0026gt;\u0026gt;\u0026gt; '0b10000000000' chr(int) : 转换数字为相应ASCI码字符。 chr(65) \u0026gt;\u0026gt;\u0026gt; 'A' ord(str) : 转换ASCI字符相应的数字。 ord('A') \u0026gt;\u0026gt;\u0026gt; 65  其他操作\nid()： 返回一个对象的唯一标识值。 type()：返回一个对象的类型。 locals()：返回当前局部变量的字典 globals()：返回当前全局变量的字典。 isinstance()：判断一个对象是否为该类的一个实例。 issubclass()：判断一个类是否为另一个类的子类。 help()：调用系统内置的帮助系统。 hash(object)：返回一个对象的hash值，具有相同值的object具有相同的hash值。 hash('python') \u0026gt;\u0026gt;\u0026gt; 7070808359261009780 reversed(sequence)：生成一个反转序列的迭代器。 reversed('abc') \u0026gt;\u0026gt;\u0026gt; ['c','b','a'] eval()：执行一个表达式，或字符串作为运算。 eval('1+1') \u0026gt;\u0026gt;\u0026gt; 2 exec()：执行python语句。 exec('print(\u0026quot;Python\u0026quot;)') \u0026gt;\u0026gt;\u0026gt; Python next(iterator[, default])：接收一个迭代器，返回迭代器中的数值，如果设置了default，则当迭代器中的元素遍历后，输出default内容。  5、什么是元类?元类的应用场景有哪些，能具体说说吗？ 在python 中，万物皆对象。对象是通过类实例化的结果，类是元类实例化的结果，也就是创建类的类。\n一个类在实例化的过程中，做了以下事情\n 触发元类(创建这个类的类)的 __call__ 方法（通过对象+()的方式触发） 通过 __new__ 方法产生一个空对象（在 __init__触发前触发） 通过 __init__方法初始化这个对象（在实例化的时候触发） 返回这个对象  元类的应用场景\n ORM(Object Relational Mapping) , 即对象-关系映射,就是将关系数据库的一行记录映射为一个对象,一个类对应一个表 实现单例模式  ","id":1,"section":"posts","summary":"python基础面试题 1、手写一个完整的装饰器模板 # 用于修复被装饰对象的名称空间 from functools import wrape def wapper(func): @wraps(func) def inner(*args, **kwargs): # func执行前的操作 res = func(*args, **kwargs) # func","tags":["装饰器","单例","元类"],"title":"python基础面试题01","uri":"https://xiaodan1040.github.io/python-interview01/","year":"2019"}],"tags":[{"title":"元类","uri":"https://xiaodan1040.github.io/tags/%E5%85%83%E7%B1%BB/"},{"title":"单例","uri":"https://xiaodan1040.github.io/tags/%E5%8D%95%E4%BE%8B/"},{"title":"并发量","uri":"https://xiaodan1040.github.io/tags/%E5%B9%B6%E5%8F%91%E9%87%8F/"},{"title":"装饰器","uri":"https://xiaodan1040.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"}]}